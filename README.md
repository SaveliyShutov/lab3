## Задача 1. Имена (старая версия)

**Условие:**  
Создайте сущность Имя, которая описывается тремя параметрами: Фамилия, Личное имя,
Отчество. Имя может быть приведено к строковому виду, включающему традиционное
представление всех трех параметров: Фамилия Имя Отчество (например “Иванов Иван
Иванович”). Необходимо предусмотреть возможность того, что какой-либо из параметров может
быть не задан, и в этом случае он не учитывается при приведении к текстовому виду.
Необходимо создать следующие имена:
 Клеопатра
 Пушкин Александр Сергеевич
 Маяковский Владимир
Обратите внимание, что при выводе на экран, не заданные параметры никак не участвуют в
образовании строки.

**Класс `Name`:**  
- **Поля (private)**:  
  - `last_name_` — фамилия  
  - `first_name_` — имя  
  - `middle_name_` — отчество  
- **Конструкторы:**  
  - Конструктор по умолчанию (пустые строки)  
  - Конструктор с параметрами для инициализации всех трех полей  
- **Методы:**  
  - `to_string()` — формирует строковое представление, объединяя непустые поля с пробелами  
  - `print()` — выводит строку на экран  

**Алгоритм работы кода:**  
1. Создаются объекты `Name` с разными параметрами (фамилия, имя, отчество).  
   - Если какой-либо параметр не задан, конструктор ставит пустую строку.  
2. Вызывается метод `to_string()` у каждого объекта:  
   - Он проверяет каждое поле: если поле не пустое, добавляет его к результирующей строке.  
   - Поля соединяются пробелами.  
3. Метод `print()` просто вызывает `to_string()` и выводит результат на экран через `std::cout`.  
4. В итоге на экране появляется корректное имя с учётом непустых полей.  

**Пример выполнения:**  
```
Клеопатра
Пушкин Александр Сергеевич
Маяковский Владимир
```
---

## Задача 2. Дома

**Условие:**  
Дом.
Создайте сущность Дом, которая описывается количеством этажей в виде числа. У Дома можно
запросить текстовую форму, которое имеет представление вида “дом с N этажами”, где N это
число. Гарантировать правильное окончание фразы, в зависимости от количества этажей. Создать
и вывести на экран дома с 1, 5, 23 этажами.

**Класс `House`:**  
- **Поля (private):**  
  - `floors_` — количество этажей  
- **Методы (private):**  
  - `get_floor_word(int n)` — возвращает слово `"этажом"` или `"этажами"` в зависимости от числа  
- **Методы (public):**  
  - Конструктор `House(int floors)` — устанавливает минимальное значение этажей в 1  
  - `to_string()` — формирует строку `"дом с N этажом/этажами"`  
  - `print()` — выводит результат на экран  

**Алгоритм работы кода:**  
1. Создаётся объект `House` с числом этажей.  
   - Конструктор проверяет, что этажей хотя бы 1.  
2. Вызывается `to_string()`:
   - Вызывает приватный метод `get_floor_word(int n)`, чтобы выбрать правильное окончание слова `"этаж/этажами"`.
   - Метод проверяет последние цифры числа:
     - Если число оканчивается на 1 (но не 11), возвращает `"этажом"`.
     - Если оканчивается на 2–4 (но не 12–14), возвращает `"этажами"`.
     - Для всех остальных случаев возвращает `"этажами"`.  
3. Собирается итоговая строка `"дом с N этаж/этажами"`.
4. `print()` выводит результат на экран.

**Пример выполнения:**  
```
дом с 1 этажом
дом с 5 этажами
дом с 23 этажами
```
---

## Задача 3. Сотрудники и отделы (старая версия)

**Условие:**  
Сотрудники и отделы.
Создайте сущность Сотрудник, которая описывается именем (в строковой форме) и отделом, в
котором сотрудник работает, причем у каждого отдела есть название и начальник, который
также является Сотрудником. Сотрудник может быть приведен к текстовой форме вида: “Имя
работает в отделе Название, начальник которого Имя”. В случае если сотрудник является
руководителем отдела, то текстовая форма должна быть “Имя начальник отдела Название”.
Необходимо выполнить следующие задачи:
1. Создать Сотрудников Петрова, Козлова, Сидорова работающих в отделе IT.
2. Сделать Козлова начальником IT отдела.
3. Вывести на экран текстовое представление всех трех Сотрудников (у всех троих должен
оказаться один и тот же отдел и начальник).

### Employee
**Поля (private):**  
- `name_` — имя сотрудника  
- `department_` — указатель на отдел  

**Методы (public):**  
- Конструктор `Employee(name, department)` — создаёт сотрудника  
- `set_department(department)` — смена отдела  
- `get_name()` — возвращает имя  
- `to_string()` — строковое представление с отделом и начальником  
- `print()` — выводит строку в консоль  
---

### Department
**Поля (private):**  
- `name_` — название отдела  
- `manager_` — указатель на начальника  

**Методы (public):**  
- Конструктор `Department(name)` — создаёт отдел  
- `set_manager(manager)` — назначает начальника  
- `get_manager()` — возвращает начальника  
- `get_name()` — возвращает название отдела  
---

**Алгоритм работы кода:**  
1. Создаётся объект `Department` с названием отдела.  
2. Создаём объекты `Employee`, передавая имя и ссылку на отдел.  
3. Назначаем начальника через `Department::set_manager(Employee*)`.  
   - Внутри отдела сохраняется указатель на начальника.  
4. Метод `Employee::to_string()` формирует строку:
   - Если сотрудник — начальник отдела, строка `"Имя начальник отдела Название"`.
   - Если не начальник, строка `"Имя работает в отделе Название, начальник которого Имя"`.  
5. Метод `print()` выводит текстовое представление на экран.  

**Пример выполнения:**  
```
Петров работает в отделе IT, начальник которого Козлов
Козлов начальник отдела IT
Сидоров работает в отделе IT, начальник которого Козлов
```
---

## Задача 4. Сотрудники и отделы (новая версия с коллегами)

**Условие:**  
Сотрудники и отделы.
Измените решение, полученное в задаче 2.4 таким образом, чтобы имея ссылку на сотрудника,
можно было бы узнать список всех сотрудников этого отдела.
## Классы Employee2 / Department2

### Employee2
**Поля (private):**  
- `name_` — имя сотрудника  
- `department_` — указатель на отдел (`Department2`)  

**Методы (public):**  
- Конструктор `Employee2(name, department)` — создаёт сотрудника и автоматически добавляет его в отдел  
- `set_department(department)` — назначает отдел и добавляет сотрудника в список отдела  
- `get_name()` — возвращает имя сотрудника  
- `to_string()` — строковое представление: если сотрудник начальник — `"Имя начальник отдела Название"`, иначе `"Имя работает в отделе Название, начальник которого Имя"`  
- `print()` — вывод строки `to_string()` на экран  
- `get_colleagues()` — возвращает вектор всех сотрудников отдела, кроме текущего  

---

### Department2
**Поля (private):**  
- `name_` — название отдела  
- `manager_` — указатель на начальника отдела  
- `employees_` — вектор указателей на сотрудников отдела  

**Методы (public):**  
- Конструктор `Department2(name)` — создаёт отдел  
- `set_manager(manager)` — назначает начальника и автоматически добавляет его в список сотрудников  
- `get_manager()` — возвращает указатель на начальника отдела  
- `get_name()` — возвращает название отдела  
- `add_employee(employee)` — добавляет сотрудника в вектор, если его там ещё нет  
- `get_employees()` — возвращает вектор всех сотрудников отдела  


**Алгоритм работы кода:**  
1. Создаётся объект `Department2` с названием отдела и пустым вектором сотрудников.  
2. Создаются объекты `Employee2` с ссылкой на отдел:
   - В конструкторе `Employee2` автоматически вызывается `department_->add_employee(this)`, чтобы добавить сотрудника в список отдела.  
3. Назначение начальника через `Department2::set_manager(Employee2*)`:
   - Устанавливается поле `manager_`.
   - Начальник добавляется в вектор сотрудников (если ещё не добавлен).  
4. Метод `get_colleagues()` возвращает всех сотрудников отдела, кроме текущего:  
   - Проходит по `department_->get_employees()`.  
   - Если сотрудник не равен текущему объекту (`this`), добавляет в результат.  
5. Метод `to_string()` формирует строку как в старой версии (с учётом роли).  
6. `print()` выводит на экран имя и должность.  

**Пример выполнения:**  
```
Петров работает в отделе IT, начальник которого Козлов
Козлов начальник отдела IT
Сидоров работает в отделе IT, начальник которого Козлов

Список коллег:
Петров коллеги: Козлов, Сидоров
Козлов коллеги: Петров, Сидоров
Сидоров коллеги: Петров, Козлов
```
---

## Задача 5. Имена (новая версия)

**Условие:**  
Создаем Имена.
Измените сущность Имя из задачи 1.3. Новые требования включают:
 Имя можно создать указав только Личное имя
 Имя можно создать указав Личное имя и Фамилию.
 Имя можно создать указав все три параметра: Личное имя, Фамилию, Отчество.
Необходимо создать следующие имена:
1. Клеопатра
2. Александр Сергеевич Пушкин
3. Владимир Маяковский
4. Христофор Бонифатьевич (здесь Христофор это имя, а Бонифатьевич - фамилия) 

## Класс Name2 (новая версия имени)

**Поля (private):**  
- `first_name_` — имя сотрудника/человека  
- `last_name_` — фамилия (может быть пустой)  
- `patronymic_` — отчество (может быть пустое)  

**Методы (public):**  
- **Конструкторы:**  
  - `Name2(first_name)` — только имя  
  - `Name2(first_name, last_name)` — имя и фамилия  
  - `Name2(first_name, last_name, patronymic)` — все три параметра  
- `to_string()` — формирует строку в формате `"Фамилия Имя Отчество"`, пропуская пустые поля  
- `print()` — выводит результат `to_string()` в консоль  

**Алгоритм работы кода:**  
1. Создаются объекты `Name2` с разными комбинациями параметров:
   - Личное имя  
   - Имя + фамилия  
   - Имя + фамилия + отчество  
2. Метод `to_string()` собирает строку:
   - Если фамилия или отчество пустые, они игнорируются.  
   - Личное имя всегда добавляется.  
   - Поля соединяются пробелами.  
3. `print()` выводит результат на экран.
**Пример выполнения:**  
```
Клеопатра
Александр Пушкин Сергеевич
Владимир Маяковский
Христофор Бонифатьевич
```
